<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>点位，长度，面积测量</title>
    <script src="../../Build/Cesium/Cesium.js"></script>
    <style>
        @import "../common.css";
        @import "../../Build/Cesium/Widgets/widgets.css";
    </style>
</head>
<body>
<div>
    <button id="point" >点位测量</button>
    <button id="length" >长度测量</button>
    <button id="area" >面积测量</button>
    <button id="clearMeasureData" disabled="disabled">清空计算结果</button>
</div>
<div id="CesiumContainer"></div>

<script>
    //单独每个功能都已实现， need 整合
    Cesium.BingMapsApi.defaultKey="Ai50Y21LEk2ZbEcY78R_vXpCk6gZvZ9dxuGoMHppV-nzLuTkfDz1wNt8knbly0zW";
    const viewer=new Cesium.Viewer("CesiumContainer");
    let handler=new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    //用于点，线，面的创建
    var entity=undefined;
    var cartesian3Array=[];
    //用于成功创建后entity清空用
    var measureEntities=[];
    const projection=new Cesium.WebMercatorProjection();
    document.getElementById("point").onclick=function () {
        //设置inputAction

        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            let cartographic=Cesium.Cartographic.fromCartesian(cartesian);
            //可能需要东西经，南北纬

            let longtitude=Cesium.Math.toDegrees(cartographic.longitude);
            let latitude=Cesium.Math.toDegrees(cartographic.latitude);
            //
            let str='';
            str+=Math.abs(longtitude.toFixed(2));
            if(longtitude>0)
                str+='E';
            else str+='W';
            str+=' '+Math.abs(latitude.toFixed(2));
            if(latitude>0){
                str+='N';
            }else str+='S';
            if(cartesian){
                entity=addPoint(cartesian,new Cesium.LabelGraphics({
                    text:str,
                    scale:0.35,
                    pixelOffset:new Cesium.Cartesian2(10,-10)//右上角偏移
                }));
                //加入计算结果中，以便删除
                measureEntities.push(entity);
                updateClearMeasureButton();
                reset();
                handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    };
    //采用每个点
    document.getElementById("length").onclick=function () {

        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            if(cartesian){
                cartesian3Array.push(cartesian);
                if(entity!==undefined){
                    viewer.entities.remove(entity);
                    entity=addLine(cartesian3Array,cartesian3Array[parseInt(cartesian3Array.length/2)],new Cesium.LabelGraphics({
                        text:calcLength(cartesian3Array).toFixed(2)+' m',
                        scale:0.35
                    }));
                }else {
                    entity=addPoint(cartesian3Array[0]);
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            if(cartesian&&entity!==undefined){
                cartesian3Array.push(cartesian);
                viewer.entities.remove(entity);
                entity=addLine(cartesian3Array,cartesian3Array[parseInt(cartesian3Array.length/2)],new Cesium.LabelGraphics({
                    text:calcLength(cartesian3Array).toFixed(2)+' m',
                    scale:0.35
                }));
                //加入计算结果中，以便删除
                measureEntities.push(entity);
                updateClearMeasureButton();

                reset();
                handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK );
    };
    //采用第一个是点，第二个便是线，三+就是面
    document.getElementById("area").onclick=function () {

        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            if(cartesian){
                cartesian3Array.push(cartesian);
                if(entity!==undefined){
                    viewer.entities.remove(entity);
                    if(cartesian3Array.length===2){
                        entity=addLine(cartesian3Array);
                    }else{
                        entity=addpolygon(
                            new Cesium.PolygonHierarchy(cartesian3Array),
                            cartesian3Array[parseInt(cartesian3Array.length/2)],
                        new Cesium.LabelGraphics({
                            text:calcArea(cartesian3Array).toFixed(2)+' m^2',
                            scale:0.35
                        }));
                    }
                }
                else {
                    entity=addPoint(cartesian3Array[0]);
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            if(cartesian&&entity!==undefined){
                cartesian3Array.push(cartesian);
                viewer.entities.remove(entity);
                entity=addpolygon(
                    new Cesium.PolygonHierarchy(cartesian3Array),
                    cartesian3Array[parseInt(cartesian3Array.length/2)],
                    new Cesium.LabelGraphics({
                        text:calcArea(cartesian3Array).toFixed(2)+' m^2',
                        scale:0.35
                    }));
                //加入计算结果中，以便删除
                measureEntities.push(entity);
                updateClearMeasureButton();
                //reset
                reset();
                handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

            }
        }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK );
    };
    document.getElementById('clearMeasureData').onclick=function () {
        cleanMeasureData();
    };

    function addpolygon(polygonHierarchy,labelPosition,label) {
        return viewer.entities.add({
            position:labelPosition,
            polygon:new Cesium.PolygonGraphics({
                hierarchy:polygonHierarchy
            }),
            label:label
        });
    }
    function addLine(positions,labelPosition,label) {
        return viewer.entities.add({
            position:labelPosition,
            polyline:new Cesium.PolylineGraphics({
                positions:positions
            }),
            label:label
        });
    }
    function addPoint(position,label) {
        return viewer.entities.add({
            position:position,
            point:new Cesium.PointGraphics({
                pixelSize:10
            }),
            label:label
        });
    }
    //只有在MeasureEntities 不为空时才会点击清空测量结果
    function updateClearMeasureButton() {
        if(measureEntities.length>0){
            document.getElementById('clearMeasureData').removeAttribute('disabled');
        }else{
            document.getElementById('clearMeasureData').setAttribute('disabled','disabled');
        }
    }
    /**
     *将单次画entity清空，以便下次绘画
     */
    function reset() {
        entity=undefined;
        cartesian3Array=[];
    }
    function cleanMeasureData() {
        if(entity!==undefined){
            viewer.entities.remove(entity);
            reset();
        }
        if(handler!==undefined){
            handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }
        for(let i=0;i<measureEntities.length;++i){
            viewer.entities.remove(measureEntities[i]);
        }
        measureEntities=[];
    }
    /**
     * 计算线的长度
     * @param cartesian3Points Array
     * @returns {number}
     */
    function calcLength(cartesianPoints) {
        var newarray=[];
        for(let i=0;i<cartesianPoints.length;++i){
            let cartographic=Cesium.Cartographic.fromCartesian(cartesianPoints[i]);
            newarray[i]=projection.project(cartographic);
        }
        var answer=0;
        for(let i=1;i<newarray.length;++i){
            answer+= Math.abs(Cesium.Cartesian3.distanceSquared(newarray[i-1],newarray[i]));
        }
        return answer;
    }

    /**
     * 计算面积，用的GIS基础理论中的算法
     * @param cartesianPoints Array
     * @returns {number}
     */
    function calcArea(cartesianPoints) {
        var answer=0;
        var projectionPoints=[];
        var len=cartesianPoints.length;
        for(let i=0;i<len;++i){
            let cartesian=Cesium.Cartographic.fromCartesian(cartesianPoints[i]);
            projectionPoints.push(projection.project(cartesian));
        }
        for(let i=0;i<len;++i){
            answer+=(projectionPoints[i].x-projectionPoints[(i+1)%len].x)*(Math.abs(projectionPoints[i].y)+Math.abs(projectionPoints[(i+1)%len].y));
        }
        return answer;
    }
</script>
</body>
</html>