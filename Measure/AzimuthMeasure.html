<!DOCTYPE html>
<!--
create author 路建成
date 2018.3.19
add use strict
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>方位角测量</title>
    <script src="../../Build/Cesium/Cesium.js"></script>
    <script src="../js/EditorModule.js"></script>
    <script src="../js/MeasureModule.js"></script>
    <style>
        @import "../common.css";
        @import "../../Build/Cesium/Widgets/widgets.css";
    </style>
</head>
<body>
<button id="angle">方位角测量</button>
<div id="CesiumContainer"></div>

<script>
    'use strict';
    /**
     * 方位角计算
     * 从正北方向开始算，返回方位角
     */
    Cesium.BingMapsApi.defaultKey="Ai50Y21LEk2ZbEcY78R_vXpCk6gZvZ9dxuGoMHppV-nzLuTkfDz1wNt8knbly0zW";
    const viewer=new Cesium.Viewer("CesiumContainer");
    const handler=new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    const projection=new Cesium.WebMercatorProjection();
    var entities=[];
    document.getElementById('angle').onclick=function () {
        handler.setInputAction(function (move) {
            let cartesian=viewer.camera.pickEllipsoid(move.position,viewer.scene.globe.ellipsoid);
            if(cartesian){
                Globe._cartesian3Array_.push(cartesian);
                let len=Globe._cartesian3Array_.length;
                if(len%2===0){
                    //delete
                    viewer.entities.remove(entities[entities.length-1]);
                    entities.pop();

                    let angle=decorateCalcAzimuth(Globe._cartesian3Array_[len-1],Globe._cartesian3Array_[len-2]);
                    let left=generateVerticalLine(Globe._cartesian3Array_[len-1],Globe._cartesian3Array_[len-2]);
                    //画两条线
                    entities.push(Editor.addLine([Globe._cartesian3Array_[len-2],left],undefined,undefined,{
                        width:5.0
                    }));
                    entities.push(Editor.addLine(
                        [Globe._cartesian3Array_[len-2],Globe._cartesian3Array_[len-1]],
                        Globe._cartesian3Array_[len-2],
                        new Cesium.LabelGraphics({
                            text:angle.toFixed(2)+'度',
                            scale:0.5
                        }),
                        {
                            width:5.0
                        }
                    ));
                    //handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
                }else {
                    entities.push(Editor.addPoint(Globe._cartesian3Array_[Globe._cartesian3Array_.length-1]));
                }
            }
        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    };
    /**
     * input center,end 地理坐标
     * angle 方位角
     * output b地理坐标
     */
    function generateVerticalLine(center,end){
        let cartographic=Cesium.Cartographic.fromCartesian(center);
        var lat,lon;
        lon=Cesium.Math.toDegrees(cartographic.longitude);
        lat=Cesium.Math.toDegrees(cartographic.latitude)+5>=90?90:Cesium.Math.toDegrees(cartographic.latitude)+5;
        console.log(`${lon},${lat}`);
        let answer=Cesium.Cartesian3.fromDegrees(lon,90);

        return answer;
    }
     /**
      * 将世界坐标转化为webMercator投影坐标,给calcAzimuth方法用
      */
    function decorateCalcAzimuth(start,end) {
        //返回经纬度坐标（角度表示）
        let start1=Cesium.Cartographic.fromCartesian(start);
        let end1=Cesium.Cartographic.fromCartesian(end);

        return calcAzimuth(projection.project(start1),projection.project(end1));
    }
    /**
     *  要投影坐标
     * @param start 起始坐标
     * @param end 终止坐标
     * @return 返回方位角 0-360
     */
    function calcAzimuth(start,end) {
        var angle=Math.atan((end.x-start.x)/(end.y-start.y))*180/Math.PI;
        if(start.y>end.y){
            if(start.x>end.x){

            }else{
                angle+=360;
            }
        }else{
            angle+=180;
        }
        return angle;
    }
</script>
</body>
</html>